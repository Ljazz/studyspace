<!-- TOC -->

- [1 Go语言中的并发编程](#1-go语言中的并发编程)
  - [1.1 并发性](#11-并发性)
    - [1.1.1 并发与并行](#111-并发与并行)
  - [1.2 goroutine](#12-goroutine)
    - [1.2.1 使用goroutine](#121-使用goroutine)
    - [1.2.2 启动单个goroutine](#122-启动单个goroutine)
    - [1.2.3 启动多个goroutine](#123-启动多个goroutine)
  - [1.3 goroutine与线程](#13-goroutine与线程)
    - [1.3.1 可增长的栈](#131-可增长的栈)
    - [1.3.2 goroutine调度](#132-goroutine调度)
    - [1.3.3 GOMAXPROCES](#133-gomaxproces)
  - [1.4 Channel](#14-channel)
    - [1.4.1 channel类型](#141-channel类型)
    - [1.4.2 创建channel](#142-创建channel)
    - [1.4.3 channel操作](#143-channel操作)
    - [1.4.4 无缓冲的通道](#144-无缓冲的通道)
    - [1.4.5 有缓冲的通道](#145-有缓冲的通道)
    - [1.4.6 for range从通道循环取值](#146-for-range从通道循环取值)
    - [1.4.7 单向通道](#147-单向通道)
  - [1.5 worker pool(goroutine池)](#15-worker-poolgoroutine池)
  - [1.6 select多路复用](#16-select多路复用)
  - [1.7 并发安全和锁](#17-并发安全和锁)
    - [1.7.1 互斥锁](#171-互斥锁)
    - [1.7.2 读写互斥锁](#172-读写互斥锁)
    - [1.7.3 sync.WaitGroup](#173-syncwaitgroup)
    - [1.7.4 sync.Once](#174-synconce)
    - [1.7.5 sync.Map](#175-syncmap)
  - [1.8 原子操作](#18-原子操作)
    - [1.8.1 atomic包](#181-atomic包)

<!-- /TOC -->

# 1 Go语言中的并发编程

## 1.1 并发性

### 1.1.1 并发与并行

**并发**：同一时间段内执行多个任务

**并行**：同一时刻执行多个任务

Go语言的并发通过`goroutine`实现。`goroutine`类似于线程，属于用户态的线程，可以根据需要创建成千上万个`goroutine`并发工作。`goroutine`是由Go语言的运行时（runtime）调度完成，而线程是由操作系统调度完成。

Go语言还提供`channel`在多个`goroutine`间进行通信。`goroutine`和`channel`是Go语言秉承的CSP（Communicating Sequential Process）并发模式的重要实现基础。

## 1.2 goroutine

Go语言中的`goroutine`是一种程序员只需要定义很多个任务，让系统去帮助我们把这些任务分配到CPU上实现并发执行。`goroutine`的概念类似于线程，但`goroutine`是由Go的运行时（runtime）调度和管理的。Go程序会智能地将goroutine中的任务合理地分配给每个CPU。Go语言在语言层面已经内置了调度和上下文切换的机制。

### 1.2.1 使用goroutine

Go中使用`goroutine`非常简单，只需要在调用函数的时候在前面加上`go`关键字，就可以为一个函数创建一个`goroutine`。

一个`goroutine`必定对应一个函数，可以创建多个`goroutine`去执行相同的函数。

### 1.2.2 启动单个goroutine

启动goroutine的方式非常简单，只需要在调用的函数（普通函数和匿名函数）前面加上一个`go`关键字。

示例代码

```go
func hello() {
    fmt.Println("Hello Goroutine!")
}
func main() {
    hello()
    fmt.Println("main goroutine done!")
}
```
上述示例的执行步骤是：先执行hello函数，然后再执行下面的打印语句。

```go
func main() {
    go hello() // 启动另外一个goroutine去执行hello函数
    fmt.Println("main goroutine done!")
}
```
上面示例中在`hello`函数前面加上了关键字`go`，也就是启动一个goroutine去执行hello这个函数。

在程序启动时，Go程序就会为了`main()`函数创建一个默认的`goroutine`。当main()函数返回的时候该`goroutine`就结束了，所有在`main()`函数中启动的`goroutine`会一同结束。

```go
func main() {
    go hello() // 启动两外一个goroutine去执行hello函数
    fmt.Println("main goroutine done!")
    time.Sleep(time.Second)
}
```

### 1.2.3 启动多个goroutine

在Go中实现并发就是这样简单，还可以启动多个`goroutine`。(使用了`sync.WaitGroup`来实现goroutine的同步)

```go
var wg sync.WaitGroup

func hello(i int) {
    defer wg.Done()  // goroutine结束就登记-1
    fmt.Println("Hello Goroutine!")
}

func main() {
    for i := 0; i < 10; i++ {
        wg.Add(1) // 启动一个goroutine就登记+1
        go hello(i)
    }
    wg.Wait() // 等待所有登记的goroutine都结束
}
```
多次执行上面的代码，会发现每次打印的数字的顺序都不一致。这是因为10个`goroutine`是并发执行的，而`goroutine`的调度是随机的。

## 1.3 goroutine与线程

### 1.3.1 可增长的栈

OS线程(操作系统线程)一般都有固定的栈内存(通常为2MB)，一个`goroutine`的栈在其生命周期开始时只有很小的栈(典型情况下2KB)，`goroutine`的栈不是固定的，他可以按需增大和缩小，`goroutine`的栈大小限制可以达到1GB，虽然极少会用到这么大。所以在Go中一次创建十万左右的`goroutine`也是可以的。

### 1.3.2 goroutine调度

`GPM`是Go语言运行时(runtime)层面的实现，是go语言自己实现的一套调度系统。区别于操作系统调度OS线程。

- `G`可以理解为是个goroutine，里面除了存放本goroutine信息外，还有与所在P的绑定等信息。
- `P`管理着一组goroutine队列，P里面会存储当前goroutine运行的上下文环境(函数指针，堆栈地址及地址边界)，P会对自己管理的goroutine队列做一些调度(如将占用CPU时间较长的goroutine暂停、运行后续的goroutine等等)当自己的队列消费完就去全局队列里取，如果全局队列里消费完了去其他P的队列抢任务。
- `M(machine)`是Go运行时(runtime)对操作系统内核线程的虚拟，M与内核线程一般是一一映射的关系，一个goroutine最终是要放到M上执行的

P与M一般也是一一对应的。它们的关系是：P管理着一组G挂载在M上运行。当一个G长久阻塞在一个M上时，runtime会新建一个M，阻塞G所在的P会把其他的G挂载在新建的M上。当旧的G阻塞完成或者认为其已经死掉时回收旧的M。

P的个数时通过`runtime.GOMAXPROCS`设定（最大256）。在并发量大的时候会增加一些P和M，但不会太多，切换太频繁的话得不偿失。

单从线程讲，Go语言相比其他语言的优势在于OS线程是由OS内核来调度的，`goroutine`则是Go运行时(runtime)自己的调度器调度的，这个调度器使用一个称为`m:n`调度的技术(复用/调度m个goroutine到n个OS线程)。其一大特点是goroutine的调度实在用户态下完成的，不涉及内核态与用户态之间的频繁切换，包括内存的分配与释放，都是在用户态维护着一块大的内存池，不直接调用系统的malloc函数(除非内存池需要改变)，成本比调度OS线程低很多。另一方面充分利用了多核的硬件资源，近似的把若干goroutine均分在物理线程上，在加上本身goroutine的超轻量，以上种种保证了go调度方面的性能

[深入Golang调度器之GMP模型](https://www.cnblogs.com/sunsky303/p/9705727.html)

### 1.3.3 GOMAXPROCES

Go运行时的调度器使用`GOMAXPROCES`参数来确定需要使用多少个OS线程来同时执行Go代码。默认值是机器上的CPU核心数。例如子在一个8核心的机器上，调度器会把Go代码同时调度到8个OS线程上(GOMAXPROCES是m:n调度中的n)

Go中可以通过`runtime.GOMAXPROCES()`函数设置当前程序并发时占用的CPU逻辑核心数。

案例：可以通过将任务分配到不同的CPU逻辑核心上实现并发的效果。

```go
func a() {
    for i := 1; i < 10; i++ {
        fmt.Println("A: ", i)
    }
}

func b() {
    for i := 1; i < 10; i++ {
        fmt.Println("B: ", i)
    }
}

func main() {
    runtime.GOMAXPROCES(1)
    go a()
    go b()
    time.Sleep(time.Second)
}
```
两个任务只有一个逻辑核心，此时是做完一个任务再做另一个任务。将逻辑核心数设为2，此时两个任务并行执行。

```go
func a() {
    for i := 1; i < 10; i++ {
        fmt.Println("A: ", i)
    }
}

func b() {
    for i := 1; i < 10; i++ {
        fmt.Println("B: ", i)
    }
}

func main() {
    runtime.GOMAXPROCES(2)
    go a()
    go b()
    time.Sleep(time.Second)
}
```

Go语言中的操作系统线程和goroutine的关系
1. 一个操作系统线程对应用户态多个goroutine
2. go程序可以同时使用多个操作系统线程
3. goroutine和OS线程是多对多的关系，即`m:n`

## 1.4 Channel

Go语言的并发模型是`CSP(Communicating Sequential Processes)`提倡<font color='red'>通过通信共享内存</font>而不是<font color='red'>通过共享内存而实现通信</font>。

如果说`goroutine`是Go程序并发的执行体，`channel`就是它们之间的连接。`channel`是可以让一个`goroutine`发送特定值到另一个`goroutine`的通信机制。

Go语言中的通道(channel)是一种特殊的类型。通道像一个传送带或者队列，总是遵循先入先出(First In First Out)的规则，保证收发数据的顺序。每一个通道都是一个具体类型的导管，也就是声明channel的时候需要为其指定元素类型。

### 1.4.1 channel类型

`channel`是一种类型，一种引用类型。声明通道类型的格式如下

```go
var 变量 chan 元素类型
```

例子
```go
var ch1 chan int    // 声明一个传递整型的通道
var ch2 chan bool   // 声明一个传递布尔型的通道
var ch3 chan []int  // 声明一个传递int切片的通道
```

### 1.4.2 创建channel

通道是引用类型，通道类型的空值是`nil`

```go
var ch chan int
fmt.Println(ch) // <nil>
```
声明的通道需要使用`make`函数初始化之后才能使用。

创建channel的格式如下

```go
make(chan 元素类型, [缓冲大小])
```
channel的缓冲大小是可选的。

例子

```go
ch4 := make(chan int)
ch5 := make(chan bool)
ch6 := make(chan []int)
```

### 1.4.3 channel操作

通道有发送(send)、接收(receive)和关闭(close)三种操作。

发送和接收都使用`<-`符号。

定义一个通道
```go
ch := make(chan int)
```

**发送**

将一个值发送到通道中

```go
ch <- 10 // 把10发送到ch中
```

**接收**

从通道中接收值

```go
x := <- ch  // 从ch中接收值并赋值给变量x
<- ch       // 从ch中接收值，护理结果
```

**关闭**

我们通过调用内置的`close`函数关闭通道

```go
close(ch)
```

关闭通道需要注意：只有在通知接收方goroutine所有的数据都发送完毕的时候才需要关闭通道。通道是可以被垃圾回收机制回收的，它和关闭文件是不一样的，在结束操作之后关闭文件是必须要做的，但关闭通道不是必须的。

关闭后的通道有以下特点：
1. 对一个关闭的通道再发送值就会导致panic
2. 对一个关闭的通道及逆行接收会一直获取值知道通道为空
3. 对一个关闭的并且没有值的通道执行接收操作会得到对应类型的零值
4. 关闭一个已经关闭的通道会导致panic

### 1.4.4 无缓冲的通道

无缓冲的通道又称为阻塞的通道。

```go
func main() {
    ch := make(chan int)
    ch <- 10
    fmt.Println("发送成功")
}
```
上述的代码可以通过编译，但在运行时会出现错误：

```text
fatal error: all goroutines are asleep - deadlock!

goroutine 1 [chan send]:
main.main()
        .../src/github.com/Q1mi/studygo/day06/channel02/main.go:8 +0x54
```
出现上述错误的原因是，使用`ch := make(chan int)`创建的是无缓冲的通道，无缓冲的通道只有再有人接收值的时候才能发送值。即，无缓冲的通道必须有接收才能发送。

解决上述错误的方法是启用一个`goroutine`去接收值

```go
func recv(c chan int) {
    ret := <- c
    fmt.Println("接收成功", ret)
}

func main() {
    ch := make(chan int)
    go recv(ch) // 启用goroutine从通道接受值
    ch <- 10
    fmt.Println("发送成功")
}
```

无缓冲通道上的发送操作会阻塞，知道另一个`goroutine`在该通道上执行接收操作，这时值才能发送成功，两个`goroutine`将继续执行。相反，如果接收操作先执行，接收方的goroutine将阻塞，直到另一个`goroutine`在该通道上发送一个值。

使用无缓冲通道进行通信将导致发送和接收的`goroutine`同步化。因此，无缓冲通道也称为`同步通道`

### 1.4.5 有缓冲的通道

可以在使用make函数初始化通道的时候为其只当通道的容量

```go
func main() {
    ch := make(chan int, 1) // 创建一个容量为1的有缓冲区的通道
    ch <- 10
    fmt.Println("发送成功")
}
```
只要通道的容量大于0，那么该通道就是有缓冲的通道，通道的容量表示通道中能存放元素的数量。

可以使用内置的`len`函数获取通道内元素的数量，使用`cap`函数获取通道的容量。

### 1.4.6 for range从通道循环取值

当通道中发送完数据时，可以通过`close`函数来关闭通道。

当通道关闭时，再往通道发送值会引发`panic`，从该通道取值的操作会先取完通道中的值，再然后取到的值一直都是对应类型的零值。

```go
func main() {
    ch1 := make(chan int)
    ch2 := make(chan int)
    // 开启goroutine将0~100的数发送到ch1中
    go func() {
        for i := 0; i < 100; i++ {
            ch1 <- i
        }
        close(ch1)
    }()
    // 开启goroutine从ch1中接收值，并将该值的平方发送到ch2中
    go func() {
        for {
            i, ok := <- ch1 // 通道关闭后再取值ok=false
            if !ok {
                break
            }
            ch2 <- i * i
        }
        close(ch2)
    }()
    // 在主goroutine中从ch2中接收值打印
    for i := range ch2 {    // 通道关闭后会退出for range循环
        fmt.Println(i)
    }
}
```
从上面的例子中我们看到有两种方式在接收值的时候判断该通道是否被关闭，不过我们通常使用的是`for range`的方式。使用`for range`遍历通道，当通道被关闭的时候就会退出`for range`。

### 1.4.7 单向通道

很多时候在不同的任务函数中使用通道都会对其进行限制，比如限制通道在函数中只能发送或只能接收。

Go中提供了<font color='red'>单向通道</font>。

```go
func counter(out chan<- int) {
    for i := 0; i < 100; i++ {
        out <- i
    }
    close(out)
}

func squarer(out chan<- int, in <-chan int) {
    for i := range in {
        out <- i * i
    }
    close(out)
}

func printer(in <-chan int) {
    for i := range in {
        fmt.Println(i)
    }
}

func main() {
    ch1 := make(chan int)
    ch2 := make(chan int)
    go counter(ch1)
    go squarer(ch1, ch2)
    printer(ch2)
}
```
其中
- `chan<- int`是一个只写单向通道（只能对其写入int类型值），可以对其执行发送操作但是不能执行接收操作；
- `<-chan int`是一个只读单向通道（只能从其读取int类型值），可以对其执行接收操作但是不能执行发送操作。

在函数传参及任何赋值操作中可以将双向通道转换为单向通道，但反过来不可以取的。

**通道常见的异常**

![channel常见的异常](images/channel常见的异常.png)

## 1.5 worker pool(goroutine池)

```go
func worker(id int, jobs <-chan int, results chan<- int) {
    for j := range jobs {
        fmt.Printf("worker:%d start job:%d\n", id, j)
        time.Sleep(time.Second)
        fmt.Printf("worker:%d end job:%d\n", id, j)
        results <- j * 2
    }
}

func main() {
    jobs := make(chan int, 100)
    results := make(chan int, 100)
    // 开启3个goroutine
    for w := 1; w <= 3; w++ {
        go worker(w, jobs, results)
    }
    // 5个任务
    for j := 1; j <= 5; j++ {
        jobs <- j
    }
    close(jobs)
    // 输出结果
    for a := 1; a <= 5; a++ {
        <- results
    }
}
```

## 1.6 select多路复用

在有些场景中，我们需要同时从多个通道接收数据。通道在接收数据时，如果没有数据可以接收将会发生阻塞。

```go
for{
    // 尝试从ch1接收值
    data, ok := <- ch1
    // 尝试从ch2接收值
    data, ok := <- ch2
}
```
上述方式虽然实现从多个通道接收值的需求，但是运行性能会差很多。Go内置的`select`可以应对上述问题，`select`可以同时响应多个通道的操作。

`select`的使用类似于switch语句，它有一系列case分支和一个默认分支。每个case会对应一个通道的通信（接收或发送）过程。`select`会一直等待，知道某个`case`的通信操作完成时，就会执行`case`分支对应的语句。具体格式如下

```go
select {
    case <-ch1:
        ...
    case data := <-ch2:
        ...
    case ch3<-data:
        ...
    default:
        默认操作
}
```

案例
```go
func main() {
    ch := make(chan int, 1)
    for i := 0; i < 10; i++{
        select{
            case x := <-ch:
                fmt.Println(x)
            case ch <- i:
        }
    }
}
```
使用`select`语句能提高代码的可读性
- 可处理一个或多个channel的发送/接收操作
- 如果多个case同时满足，select会随机选择一个。
- 对于没有case的select{}会一直等待，可用于阻塞main函数

## 1.7 并发安全和锁

在Go代码中有时候可能存在多个`goroutine`同时操作一个资源（临界区），这种情况会发生`竞态问题`（数据竞态）。

```go
var x int64
var wg sync.WaitGroup

func add() {
    for i := 0; i < 5000; i++ {
        x = x + 1
    }
}
func main() {
    wg.Add(2)
    go add()
    go add()
    wg.Wait()
    fmt.Println(x)
}
```
上面的代码中我们开启了两个`goroutine`去累加变量`x`的值，这两个`goroutine`在访问和修改`x`变量的时候就会存在数据竞争，导致最后的结果与期待的不符。

### 1.7.1 互斥锁

**互斥锁**是一种常用的控制共享资源访问的方法，它能够保证同时只有一个`goroutine`可以访问共享资源。Go中使用`sync`包的`Mutex`类型来实现互斥锁。

```go
var x int64
var xg sync.WaitGroup
var lock sync.Mutex

func add() {
    for i := 0; i < 5000; i++ {
        lock.Lock() // 枷锁
        x = x + 1
        lock.Unlock()   // 解锁
    }
}
func main() {
    wg.Add(2)
    go add()
    go add()
    wg.Wait()
    fmt.Println(x)
}
```
使用互斥锁能够保证同一时间有且只有一个`goroutine`进入临界区，其他的`goroutine`则在等待锁；当互斥锁释放后，等待的`goroutine`才可以获取锁进入临界区，多个`goroutine`同时等待一个锁时，唤醒的策略是随机的。

### 1.7.2 读写互斥锁

互斥锁是完全互斥的，但是有很多实际的场景下是读多写少的，当我们开发去读取一个资源不涉及资源修改的时候是没有必要加锁的，这种场景下使用读写锁是更好的一种选择。读写锁在Go语言中使用`sync`包中的`RWMutex`类型。

读写锁分为两种：读锁和写锁。

当一个goroutine获取读锁之后，其他的goroutine如果是获取读锁会继续获得锁，如果是获取写锁就会等待；当一个goroutine获取写锁之后，其他的goroutine无论是获取读锁环视写锁都会等待。

**示例**：读写锁

```go
var (
    x int64
    wg sync.WaitGroup
    lock sync.Mutex
    rwlock sync.RWMutex
)

func write() {
    // lock.Lock() // 加互斥锁
    rwlock.Lock()   // 加写锁
    x = x + 1
    time.Sleep(10 * time.Millisecond)   // 假设读写操作耗时10毫秒
    rwlock.Unlock() // 解写锁
    // lock.Unlock()
    wg.Done()
}

func read() {
    // lock.Lock()      // 加互斥锁
    rwlock.RLock()  // 加读锁
    time.Sleep(time.Millisecond) // 假设读操作耗时1毫秒
    rwlock.RUnlock()    // 解读锁
    // lock.Unlock()    // 解互斥锁
    wg.Donw()
}

func main() {
    start := time.Now()
    for i := 0; i < 10; i++{
        wg.Add(1)
        go write()
    }
    
    for i := 0; i < 1000; i++{
        wg.Add(1)
        go read()
    }

    wg.Wait()
    end := time.Now()
    fmt.Println(end.Sub(start))
}
```

### 1.7.3 sync.WaitGroup

代码中生硬的使用`time.Sleep`是不合适的，Go语言中可以使用`sync.WaitGroup`来实现并发任务的同步。`sync.WaitGroup`有以下几个方法：

| 方法名 | 功能 |
| --- | --- |
| (wg *WaitGroup) Add(delta int) | 计数器+delta |
| (wg *WaitGroup) Done() | 计数器-1 |
| (wg *Waitgroup) Wait() | 阻塞直到计数器变为0 |

`sync.WaitGroup`内部维护着一个计数器，计数器的值可以增加和减少。例如当我们启动了N个并发任务时，就将计数器值增加N。每个任务完成时通过调用Done()方法将计数器减1.通过调用Wait()来等待并发任务执行完，当计算器值为0时，表示所有并发任务已经完成。

```go
var wg sync.WaitGroup

func hello() {
    defer wg.Done()
    fmt.Println("hello Goroutine!")
}

func main() {
    wg.Add(1)
    go hello()  // 启动另外一个goroutine去执行hello函数
    fmt.Println("main goroutine done!")
    wg.Wait()
}
```
需要注意`sync.WaitGroup`是一个结构体，传递的时候要传递指针。

### 1.7.4 sync.Once

Go中的`sync`包中提供了一个针对只执行一次场景的解决方案-`sync.Once`。

`sync.Once`只有一个`Do`方法，其签名如下：

```go
func (o *Once) Do(f func()) {}
```

**备注**：如果要执行的函数`f`需要传递参数就需要搭配闭包来使用。

<font color="#ba3925" size="4px">加载配置文件示例</font>

延迟一个开销很大的初始化操作到真正用到它的时候在执行是一个很好的思路。因为预先初始化一个变量(比如在init函数中完成初始化)会增加程序的启动耗时，而且有可能实际执行过程中这个变量没有用上，那么这个初始化操作就不是必须要做的。

```go
var icons map[string]image.Image

func loadIcons() {
    icons = map[string]image.Image{
        "left": loadIcon("left.png"),
        "up": loadIcon("up.png"),
        "right": loadIcon("right.png"),
        "down": loadIcon("down.png"),
    }
}

// Icon被多个goroutine调用时不是并发安全的
func Icon(name string) image.Image {
    if icons == nil {
        loadIcons()
    }
    return icons[name]
}
```
多个`goroutine`并发调用Icon函数时不是并发安全的，现代的编译器和CPU可能会在保证每个`goroutine`都满足串行一致的基础上自由地重排访问内存的顺序。loadIcons函数科恩那个会被重排为以下的结果：

```go
func loadIcons() {
    icons = make(map[string]image.Image)
    icons["left"] = loadIcon("left.png")
    icons["up"] = loadIcon("up.png")
    icons["right"] = loadIcon("right.png")
    icons["down"] = loadIcon("down.png")
}
```
上述情况下就会出现即使判断了`icons`不是nil也不意味着变量初始化完成了。考虑这种情况，想到的办法就是加互斥锁，保证初始化`icons`的时候不会被其他的`goroutine`操作，但是这样做又会引发性能问题。

使用`sync.Once`改造上述代码

```go
var icons map[string]image.Image

var loadIconsOnce sync.Once

func loadIcons() {
    icons = map[string]image.Image{
        "left": loadIcon("left.png"),
        "up": loadIcon("up.png"),
        "right": loadIcon("right.png"),
        "down": loadIcon("down.png"),
    }
}

// Icon 是并发安全的
func Icon(name string) image.Image {
    LoadIconsOnce.Do(loadIcons)
    return icons[name]
}
```

<font color="#ba3925" size="4px">并发安全的单例模式</font>

```go
package singleton

import (
    "sync"
)

type singleton struct {}

var instance *singleton
var once sync.Once

func GetInstance() *singleton {
    once.Do(func(){
        instance = &singleton{}
    })
    return instance
}
```

`sync.Once`其实内部包含一个互斥锁和一个布尔值，互斥锁保证布尔值和数据的安全，而布尔值用来记录初始化是否完成。这样设计就能保证初始化操作的时候是并发安全的并且初始化操作也不会被多次执行。

### 1.7.5 sync.Map

Go语言中内置的map不是并发安全的。

```go
var m = make(mpa[string]int)

func get(key string) int {
    return m[key]
}

func main() {
    wg := sync.WaitGroup{}
    for i := 0; i < 20; i++ {
        wg.Add(1)
        go func(n int) {
            key := strconv.Itoa(n)
            set(key, n)
            fmt.Printf("k=:%v v:=%v\n", key, get(key))
            wg.Done()
        }(i)
    }
    wg.Wait()
}
```
上面代码中当并发量多了之后代码会报`fatal error:concurrent map writes`错误。

像这种场景下就需要为map加锁来保证并发的安全性了，Go语言的`sync`包中提供了一个开箱即用的并发安全版map-`sync.Map`。开箱即用表示不用像内置的map一样使用make函数初始化就能直接使用。同时`sync.Map`内置了诸如`Store`、`Load`、`LoadOrStore`、`Delete`、`Range`等操作方法

```go
var m = sync.Map{}

func main() {
    wg := sync.WaitGroup{}
    for i := 0; i < 20; i++ {
        wg.Add(1)
        go func(n int) {
            key := strconv.Itoa(n)
            m.Store(key, n)
            value, _ := m.Load(key)
            fmt.Printf("k:=%v, v:=%v\n", key, value)
            wg.Done()
        }(i)
    }
    wg.Wait()
}
```

## 1.8 原子操作

代码中的加锁操作因为涉及内核态的上下文切换比较耗时、代价比较高。针对基本数据类型还可以使用原子操作来保证并发安全，因为原子操作是Go语言提供的方法，它在用户态就可以完成，因此性能比加锁操作更加好。Go语言中原子操作由内置的标准库`sync/atomic`提供。

### 1.8.1 atomic包

<table>
<thead>
<tr>
<th>方法</th>
<th align="center">解释</th>
</tr>
</thead>

<tbody>
<tr>
<td>func LoadInt32(addr *int32) (val int32)<br>func LoadInt64(addr *int64) (val int64)<br>func LoadUint32(addr *uint32) (val uint32)<br>func LoadUint64(addr *uint64) (val uint64)<br>func LoadUintptr(addr *uintptr) (val uintptr)<br>func LoadPointer(addr *unsafe.Pointer) (val unsafe.Pointer)</td>
<td align="center">读取操作</td>
</tr>

<tr>
<td>func StoreInt32(addr *int32, val int32)<br>func StoreInt64(addr *int64, val int64)<br>func StoreUint32(addr *uint32, val uint32)<br>func StoreUint64(addr *uint64, val uint64)<br>func StoreUintptr(addr *uintptr, val uintptr)<br>func StorePointer(addr *unsafe.Pointer, val unsafe.Pointer)</td>
<td align="center">写入操作</td>
</tr>

<tr>
<td>func AddInt32(addr *int32, delta int32) (new int32)<br>func AddInt64(addr *int64, delta int64) (new int64)<br>func AddUint32(addr *uint32, delta uint32) (new uint32)<br>func AddUint64(addr *uint64, delta uint64) (new uint64)<br>func AddUintptr(addr *uintptr, delta uintptr) (new uintptr)</td>
<td align="center">修改操作</td>
</tr>

<tr>
<td>func SwapInt32(addr *int32, new int32) (old int32)<br>func SwapInt64(addr *int64, new int64) (old int64)<br>func SwapUint32(addr *uint32, new uint32) (old uint32)<br>func SwapUint64(addr *uint64, new uint64) (old uint64)<br>func SwapUintptr(addr *uintptr, new uintptr) (old uintptr)<br>func SwapPointer(addr *unsafe.Pointer, new unsafe.Pointer) (old unsafe.Pointer)</td>
<td align="center">交换操作</td>
</tr>

<tr>
<td>func CompareAndSwapInt32(addr *int32, old, new int32) (swapped bool)<br>func CompareAndSwapInt64(addr *int64, old, new int64) (swapped bool)<br>func CompareAndSwapUint32(addr *uint32, old, new uint32) (swapped bool)<br>func CompareAndSwapUint64(addr *uint64, old, new uint64) (swapped bool)<br>func CompareAndSwapUintptr(addr *uintptr, old, new uintptr) (swapped bool)<br>func CompareAndSwapPointer(addr *unsafe.Pointer, old, new unsafe.Pointer) (swapped bool)</td>
<td align="center">比较并交换操作</td>
</tr>
</tbody>
</table>

示例

```go
package main

import (
    "fmt"
    "sync"
    "sync/atomic"
    "time"
)

type Counter interface {
    Inc()
    Load() int64
}

// 普通版
type CommonCounter struct {
    counter int64
}

func (c CommonCounter) Inc() {
    c.counter++
}

func (c CommonCounter) Load() int64 {
    return c.counter
}

// 互斥锁版
type MutexCounter struct {
    counter int64
    lock sync.Mutex
}

func (m *MutexCounter) Inc() {
    m.lock.Lock()
    defer m.lock.Unlock()
    m.counter++
}

func (m *MutexCounter) Load int64 {
    m.lock.Lock()
    defer m.lock.Unlock()
    return m.counter
}

// 原子操作版
type AtomicCounter struct {
    counter int64
}

func (a *AtomicCounter) Inc() {
    atomic.AddInt64(&a.counter, 1)
}

func (a *AtomicCounter) Load() int64 {
    return atomic.LoadInt64(&a.counter)
}

func test(c Counter) {
    var wg sync.WaitGroup
    start := time.Now()
    for i := 0; i < 1000; i++ {
        wg.Add(1)
        go func() {
            c.Inc()
            wg.Done()
        }()
    }
    wg.Wait()
    end := time.Now()
    fmt.Println(c.Load(), end.Sub(start))
}

func main() {
    c1 := CommonCounter{}   // 非并发安全
    test(c1)
    c2 := MutexCounter{}    // 使用互斥锁实现并发安全
    test(&c2)
    c3 := AtomicCounter{}   // 并发安全且比互斥锁效率更高
    test(&c3)
}
```
`atomic`包提供了底层的原子级内存操作，对于同步算法的实现很有用。这些函数必须谨慎地保证正确使用。除了某些特殊的底层应用，使用通道或者sync包的函数/类型实现同步更好。