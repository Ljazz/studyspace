<!-- TOC -->

- [1、Python的内存管理机制](#1python的内存管理机制)
  - [1.1 引用计数](#11-引用计数)
  - [2. 垃圾回收](#2-垃圾回收)
    - [2.1、什么是垃圾回收机制](#21什么是垃圾回收机制)
    - [2.2、引用计数](#22引用计数)
    - [2.3 标记清除](#23-标记清除)
    - [2.4 分代回收](#24-分代回收)
  - [3. 内存池](#3-内存池)
- [2、Python中`sort`和`sorted`的区别](#2python中sort和sorted的区别)
- [3、Python代码实现删除list里面重复元素](#3python代码实现删除list里面重复元素)
- [4、Python中赋值、浅拷贝、深拷贝](#4python中赋值浅拷贝深拷贝)
- [5、\_\_new\_\_和\_\_init\_\_区别](#5__new__和__init__区别)
- [6、利用sorted对字典和对象进行排序](#6利用sorted对字典和对象进行排序)
- [7、多线程与多进程](#7多线程与多进程)
- [8、Python中迭代器和生成器](#8python中迭代器和生成器)

<!-- /TOC -->

# 1、Python的内存管理机制

Python提供了自动化的内存管理，也就是说内存空间的分配与释放都是由Python解释器在运行时自动进行的，自动管理内存功能极大的减轻程序员的工作负担，也能够帮助程序员在一定程度上解决内存泄漏的问题。就CPython解释器而言，他的内存管理有三个关键点：引用计数、垃圾回收、内存池。

## 1.1 引用计数
它是一种非常高效的内存管理手段，当一个Python对象被引用时，其引用计数增加1；当其不再被引用时，引用计数减1，当引用计数等于0时，对象就被删除了。

## 2. 垃圾回收
### 2.1、什么是垃圾回收机制
垃圾回收机制(简称GC)是Python解释器自带的一种机制，是专门用来回收不可用的变量所占用的内存空间

### 2.2、引用计数
引用计数也是一种垃圾回收机制，而且是一种最直观，最简单的垃圾回收技术。

Python中每一个对象的核心就是一个结构体PyObject，内部有一个引用计数ob_refcnt,当python对象引用计数为0，就说明没有任何引用指向该对象，该对象就成为要被回收的垃圾了。

示例：当一个对象被创建出来，它的引用计数就会加1，当对象被引用的时候，计数继续增加；当引用它的对象被删除的时候，它的引用计数就会减少，直到变为0，此时垃圾回收机制就会将其回收。如果出现循环引用，就需要采用别的办法了。

> 注意：当把a作为参数传递给getrefcount时，会产生一个临时的引用，因此的出来的结果比真实情况+1

**引用计数增加的情况**：
- 对象被创建
- 对象被引用
- 对象作为参数传入到一个函数中
- 对象作为元素存储到一个容器中

**引用计数减少的情况**：
- 用`del`语句显示删除对象引用
- 对象引用被重新赋值其他对象
- 一个对象离开它所在的作用域
- 持有该对象的容器自身被销毁
- 持有该对象的容器删除该对象

**注意**：当两个对象互相引用的时候，del语句可以减少引用次数，但是引用计数不会归0，对象就不会被销毁，从而造成内存泄漏问题

### 2.3 标记清除
**标记清除**是用来解决循环引用产生的问题，循环引用只有在容器对象才会产生，比如字典、元组、列表等。先按需分配，等到没有空闲内存的时候，从寄存器和程序栈上的引用出发，遍历所有对象和引用把所有能访问的打标记，最后将没有标记的对象释放。

标记清除机制在进行垃圾回收时分成了两步
1. 标记阶段，遍历所有的对象，如果时可达的(reachable)，也就是还有对象引用它，那么就标记该对象为可达。
2. 清除阶段，再次遍历对象，如果发现某个对象没有标记为可达(Unreachable)，则就将其回收


### 2.4 分代回收
> 分代回收是基于这样的一个统计事实，对于程序，存在一定比例的内存块的生存周期比较短；而剩下的内存块，生存周期会比较长，甚至会从程序开始一直持续到程序结束。因此，简单的认为：对象存在时间越长，越可能不是垃圾，应该越少去收集。这样在标记-清除算法时可以有效的减小遍历的对象数，从而提高垃圾回收的速度，**是一种以空间换时间的方法策略**。

Python将所有的对象分为年轻代(第0代)、中年代(第1代)、老年代(第2代)三代。所有的新建对象默认是第0代对象。当在第0代的gc扫描中存货下来的对象将被移至第1代，在第1代的gc扫描中存货下来的对象将被移至第2代。

> gc扫描次数（第0代>第1代>第2代）

当某一代中被分配的对象与被释放的对象之差达到某一阈值时，就会触发当前一代的gc扫描。当某一代被扫描时，比它年轻的一代也会被扫描，因此，第2代的gc扫描发生时，第0，1代的gc扫描也会发生，即为全代扫描。


## 3. 内存池

Python提供了对内存的垃圾回收机制，但是它将不用的内存放到内存池而不是返回给操作系统。
1. Pymalloc机制。为了加速Python的执行效率，Python引入了一个内存池机制，用于管理对小块内存的申请和释放。
2. Python中所有小于256个字节的对象都是用pymalloc实现的分配器，而大的内存则使用系统的malloc。
3. 对于Python对象，如整数，浮点数和list，都有其独立的私有内存池，对象间不共享它们的内存池。

# 2、Python中`sort`和`sorted`的区别

`sort()`和`sorted()`两个函数都可以对序列进行排序。
- `sort()`函数会序列本身进行操作
- `sorted()`函数是在序列的副本进行操作，然后将排序后的新序列返回，并不会操作序列本身。

```python
In [1]: # sort()排序

In [2]: a = [1, 2, 4, 2, 4, 5, 7, 10, 5, 5, 7, 8, 9, 0, 3] 

In [3]: id(a)

Out[3]: 140435194119488

In [4]: a.sort()

In [5]: id(a)

Out[5]: 140435194119488

In [6]: # sorted()排序

In [7]: a = [1, 2, 4, 2, 4, 5, 7, 10, 5, 5, 7, 8, 9, 0, 3]

In [8]: id(a)

Out[8]: 140435194665344

In [9]: c = sorted(a)

In [10]: c

Out[10]: [0, 1, 2, 2, 3, 4, 4, 5, 5, 5, 7, 7, 8, 9, 10]

In [11]: id(c)

Out[11]: 140435194759808
```

# 3、Python代码实现删除list里面重复元素

1. 使用`set()`函数

```python
In [1]: a = [1, 2, 4, 2, 4, 5, 6, 5, 7, 8, 9, 0]

In [2]: set(a)

Out[2]: {0, 1, 2, 4, 5, 6, 7, 8, 9}

In [3]: list(set(a))

Out[3]: [0, 1, 2, 4, 5, 6, 7, 8, 9]

```

2. 使用字典

```python
In [1]: a = [1, 2, 4, 2, 4, 5, 6, 5, 7, 8, 9, 0]

In [2]: b = {}

In [3]: list(b.keys())

Out[3]: [1, 2, 4, 5, 6, 7, 8, 9, 0]

```

# 4、Python中赋值、浅拷贝、深拷贝

- 赋值（=），就是创建了对象的一个新的引用，修改其中任意一个变量都会影响到另一个。
- 浅拷贝：创建一个新的对象，但它包含的是对原始对象中包含项的引用（如果用引用的方式修改其中一个对象，另外一个也会修改改变）
- 深拷贝：创建一个新的对象，并且递归的复制它所包含的对象（修改其中一个，另外一个不会改变

# 5、\_\_new\_\_和\_\_init\_\_区别

1. \_\init\_\_是初始化方法，创建对象后，就会被默认调用，可以接收参数
2. \_\_new\_\_至少要有一个参数cls，代表当前类，此参数在实例化时由Python解释器自动识别
3. \_\_new\_\_必须要有返回值，返回实例化出来的实例，
4. \_\init\_\_有一个参数self，就是\_\_new\_\_返回的实例，\_\init\_\_在\_\new\_\_的基础上可以完成一些其它初始化的动作，\_\init\_\_不需要返回值
5. 如果\_\_new\_\_创建的是当前类的实例，会自动调用\_\_init\_\_函数，通过return语句里面调用的\_\_new\_\_函数的第一个参数是cls来保证是当前类实例，如果是其他类的类名，；那么实际创建返回的就是其他类的实例，其实就不会调用当前类的\_\_init\_\_函数，也不会调用其他类的\_\_init\_\_函数。

# 6、利用sorted对字典和对象进行排序

```python
In [1]: # 字典排序 

In [2]: d = {'a': 9, 'b': 2, 'd': 4, 'f': 10, 'c': 1, 'g': 3, 'e': 5}

In [3]: result = sorted(d.items(), key=lambda i: i[0], reverse=False) 

In [4]: result 

Out[4]: [('a', 9), ('b', 2), ('c', 1), ('d', 4), ('e', 5), ('f', 10), ('g', 3)]

In [5]: dict(result)

Out[5]: {'a': 9, 'b': 2, 'c': 1, 'd': 4, 'e': 5, 'f': 10, 'g': 3}

In [6]: # 对象排序 

In [7]: class A: 
   ...:     def __init__(self, num): 
   ...:         self.num = num 
   ...:

In [8]: import random

In [9]: obj_list = [A(random.randint(0, 10)) for _ in range(10)]

In [10]: obj_list

Out[10]: 
[<__main__.A at 0x7f9a7f8936d0>,
 <__main__.A at 0x7f9a7f893520>,
 <__main__.A at 0x7f9a7f8fce80>,
 <__main__.A at 0x7f9a7f8fce20>,
 <__main__.A at 0x7f9a7f8fc880>,
 <__main__.A at 0x7f9a7f8fcc10>,
 <__main__.A at 0x7f9a7f8fcca0>,
 <__main__.A at 0x7f9a7f8fc910>,
 <__main__.A at 0x7f9a7f8fcf70>,
 <__main__.A at 0x7f9a7f8fc820>]

In [11]: for item in obj_list: 
    ...:     print(item.num) 
    ...:
6
3
3
6
9
10
7
3
10
0

In [12]: result = sorted(obj_list, key=lambda i: i.num, reverse=False)

In [13]: result

Out[13]: 
[<__main__.A at 0x7f9a7f8fc820>,
 <__main__.A at 0x7f9a7f893520>,
 <__main__.A at 0x7f9a7f8fce80>,
 <__main__.A at 0x7f9a7f8fc910>,
 <__main__.A at 0x7f9a7f8936d0>,
 <__main__.A at 0x7f9a7f8fce20>,
 <__main__.A at 0x7f9a7f8fcca0>,
 <__main__.A at 0x7f9a7f8fc880>,
 <__main__.A at 0x7f9a7f8fcc10>,
 <__main__.A at 0x7f9a7f8fcf70>]

In [14]: for item in result: 
    ...:     print(item.num) 
    ...:
0
3
3
3
6
6
7
9
10
10
```

# 7、多线程与多进程

**进程**

1. 操作系统进行资源分配和调度的基本单位，多个进程之间相互独立
2. 稳定性号，如果一个进程崩溃，不影响其他进程，但是进程消耗资源大，开启的进程数量有限制。

**线程**
1. CPU进行资源分配和调度的基本单位，线程是进程的一部分，是比进程更小的能独立运行的基本单位，一个进程下的多个线程可以共享该进程的所有资源
2. 如果IO操作密集，则可以多线程运行效率高，缺点是如果一个线程崩溃，都会造成进程的崩溃

# 8、Python中迭代器和生成器

迭代器是实现了迭代器协议的对象。跟其他编程语言不同，Python中没有用于定义协议或表示约定的关键字，像`interface`、`protocol`这些单词并不在Python语言的关键字列表中。Python语言通过魔法方法来表示约定，也就是我们所说的协议，而`__next__`和`__iter__`这两个魔法方法就代表了迭代器协议。可以通过`for-in`循环从迭代器对象中取出值，也可以使用`next`函数取出迭代器对象中的下一个值。生成器是迭代器的语法升级版本，可以用更为简单的代码来实现一个迭代器。
