# 哈希算法

## 1、哈希算法的原理

常见的数据查找算法
- 顺序查找
- 二分查找
- 深度优先搜素
- 广度优先搜索
- 哈希查找

**哈希算法**原理：把复杂的数据通过某种函数映射关系，映射成更加易于查找的方式。每个数据都会映射为独一无二的地址，数据存储时，会存储与这个地址，取数据时，会在这个地址取。

## 2、哈希函数

哈希算法进行查找的基本原理是根据总体数据量预先设置一个数组，使用一个哈希哈数并以数据的关键字作为自变量，得到唯一的返回值。这样就可以利用哈希函数将数据元素映射到数组的某一位置并把数据存放在对应位置上。查询时，通过哈希函数计算该数据应该存储在哪里，再到相应的存储位置取出查找的数据。

哈希是一种高效的查找算法，也是一种高效的存储算法。哈希算法是在时间和空间上做出权衡的经典例子。

### 2.1、除法哈希算法

**除法哈希**：用每一个关键字去除以一个特定的质数，所得的余数就是该关键字的哈希值。通过x除以m的余数将关键字映射到数组的m位置中。

哈希函数公式为：$h(x)=x mod m$

按照统一的哈希函数存储数据，也按照统一的哈希函数查找数据。哈希算法和关键字的类型有关。

### 2.2、乘法哈希算法

对给定的长度为m的数组，用关键字x乘以一个常数N，N的值为大于0并小于1的一个小数，并提取出Nx的小数部分。之后用m乘以这个小数，再向下取整。

哈希函数公式为：$h(x)=\lfloor m(Nx mode 1) \rfloor$

### 2.3、平方取中法

平方取中法，首先计算出关键字的平方值，然后取平方值中间几位作为哈希地址。

哈希函数公式为：h(x) = mid(x*x, n)

### 2.4、随机数哈希算法

选择一个随机函数，以关键字作为随机函数的种子，然后以随机函数的返回值作为该关键字的哈希值。

## 3、解决冲突

由于关键字的取值可能子啊一个很大的范围，数据在通过哈希函数进行映射的时候，很难找到一个哈希函数，使得这些关键字不能映射到唯一的值，就会出现多个关键字映射到同一个值的现象，这种现象称为冲突。

解决哈希冲突的方法有
- 开放定址法：当一个关键字插入到哈希表中遇到冲突时，可以连续地检查哈希表的各个位置，直到找到一个空位置把数据插入进去为止。
  - 线性探查法：对每个关键x，通过哈希函数得到的哈希值为key，那么当发生冲突时，依次查看key+1，key+2，直到key+m-1，然后循环到哈希表的第0位，第1位，...，直到查询到某一个位置为空，把关键字存储到该位置即可
    - 公式为：$h(key, i)=(key+i)\%m, 0\leq i \leq m-1$
  - 二次探查法：二次探查法和线性探查法类似，改变的只是每次探查的偏移量，以i的二次方的方式进行变化。探查时从地址key开始，首先探查key， 然后依次探查key+1， key+4，key+9，...，直到探查到有空余的位置为止
    - 公式为：$h(key, i)=(key+i*i)\%m$
  - 双重散列法：双重散列法更进一步，需要两个哈希函数$h_1$和$h_2$，首先探查$h_1(x)$的位置，然后再次位置的基础上加上一些偏移量$i*h_2(x)$，最后再对m取余。和之前的方法不同的地方在于两个哈希函数都依赖关键x，因此不同的关键字会有不同的偏移量。
    - 公式为：$h(x, i) = (h_1(x)+i*h_2(x))\%m$
- 链地址法：这种方法处理冲突的方法本质上是一种数组加链表的处理方法。当发生多个数据通过哈希函数映射后得到相同的哈希值时，通常把具有相同哈希地址的关键字放在同一个链表中，该链表称为**同义词链表或桶**。
- 二次再散列法
- 线性探测再散列

## 4、哈希算法的应用

### 4.1、两个数的和问题

```python
# 两个数的和
def towSums(mynum, target):
    mydict = {}     # 建立一个字典，存储数据和下标的对应关系
    for i in range(len(mynum)):
        m = mynum[i]  # 定义m为当前待查询数字
        if target - m in mydict:    # 判定target-m是否已经在字典中
            return (mydict[target-m], i)    # 如果已经存在，则返回这两个数的下标
        else:
            mydict[m] = i   # 如果不存在则记录键值对


if __name__ == "__main__":
    num = [3, 4, 5, 7, 10]
    x, y = towSums(num, 11)
    print(num[x], num[y])
```

### 4.2、团体赛问题

```python
# 模式配置
def pingpong(games, players):
    game = games.split('，')
    player = players.split('，')
    if len(player) != len(game):    # 如果两个字符串的长度不一样，则肯定不匹配
        return False
    mydict = {}     # 记录模式字符串和目标字符串的对应关系
    used = {}   # 记录目前已经使用过的字符串
    for i in range(len(game)):
        if game[i] in mydict:
            if mydict[game[i]] != player[i]:    # 不是第一次出现，则检查映射关系是否一致
                return False
        else:
            if player[i] in used:   # 检查选手是否出现过，出现过不成立
                return False
            mydict[game[i]] = player[i]     # 第一次出现，则加入哈希表
            used[player[i]] = True  # 在used中保存已经使用过的。
    return True     # 没有任何问题，返回成立


if __name__ == "__main__":
    games = "男单，女双，女双，男单"
    players = "李四，张/王组合，张/王组合，李四"
    ret = pingpong(games, players)
    print(ret)
```
