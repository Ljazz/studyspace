# 算法

## 算法分类

- 比较类排序：通过比较来决定元素间的相对次序，由于其时间复杂度不能突破O(nlogn)，因此也称为非线性时间比较类排序。
- 非比较类排序：不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此也称为线性时间非比较类排序。

![算法分类](./images/排序/排序算法分类.png)

## 算法复杂度

![算法复杂度](./images/排序/算法复杂度.png)

## 相关概念

- 稳定：如果a原本在b前面，而a=b，排序之后a仍然在b的前面。
- 不稳定：如果a原本在b的前面，而a=b，排序之后 a 可能会出现在 b 的后面。
- 时间复杂度：对排序数据的总的操作次数。反映当n变化时，操作次数呈现什么规律。
- 空间复杂度：是指算法在计算机内执行时所需存储空间的度量，它也是数据规模n的函数


# 1、冒泡排序

冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。 

## 1.1 算法描述

1. 比较相邻的元素。如果第一个比第二个大，就交换它们两个；
2. 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；
3. 针对所有的元素重复以上的步骤，除了最后一个；
4. 重复步骤1~3，直到排序完成。

## 1.2 冒泡排序动图图解

![冒泡排序](./images/排序/冒泡排序.gif)

## 1.3 代码实现

```python
def bubble_sort_1(nums):
    for i in range(len(nums)-1):
        print('第{}次排序过程'.format(i+1))
        for j in range(0, len(nums)-1-i):
            if nums[j] > nums[j+1]:
                nums[j], nums[j+1] = nums[j+1], nums[j]
            print(nums)


if __name__ == "__main__":
    nums = [5, 3, 6, 4, 1, 2, 8, 7]
    print('原始数组...')
    print(nums)
    print('-'*30)
    bubble_sort_1(nums)

```

# 2、选择排序

选择排序(Selection-sort)是一种简单直观的排序算法。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。 

## 2.1 算法描述
n个记录的直接选择排序可经过n-1趟直接选择排序得到有序结果。具体算法描述如下：

1. 初始状态：无序区为R\[1..n\]，有序区为空；
2. 第i趟排序(i=1,2,3…n-1)开始时，当前有序区和无序区分别为R\[1..i-1\]和R(i..n）。该趟排序从当前无序区中-选出关键字最小的记录 R\[k\]，将它与无序区的第1个记录R交换，使R\[1..i\]和R\[i+1..n\)分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区；
3. n-1趟结束，数组有序化了。

## 2.2 选择排序动图图解

![选择排序](./images/排序/选择排序.gif)

## 2.3 代码实现

```python
def selection_sort_1(nums):
    for i in range(len(nums)):
        print('第{}次排序过程'.format(i+1))
        for j in range(i+1, len(nums)):
            if nums[i] > nums[j]:
                nums[i], nums[j] = nums[j], nums[i]
            print(nums)
        print('-'*30)


def selection_sort_2(nums):
    res = []
    while nums:
        min = nums[0]
        for item in nums:
            if min > item:
                min = item
        nums.remove(min)
        res.append(min)
    print(res)


if __name__ == "__main__":
    nums = [5, 3, 6, 4, 1, 2, 8, 7]
    print('原始数组...')
    print(nums)
    print('-'*30)
    selection_sort_2(nums)

```


# 3、插入排序

插入排序（Insertion-Sort）的算法描述是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。

## 3.1 算法描述
一般来说，插入排序都采用in-place在数组上实现。具体算法描述如下：

1. 从第一个元素开始，该元素可以认为已经被排序；
2. 取出下一个元素，在已经排序的元素序列中从后向前扫描；
3. 如果该元素（已排序）大于新元素，将该元素移到下一位置；
4. 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；
5. 将新元素插入到该位置后；
6. 重复步骤2~5。


## 3.2 插入排序动图图解

![插入排序](./images/排序/插入排序.gif)

## 3.3 代码实现

```python
def insertion_sort_1(nums):
    for i in range(1, len(nums)):
        print('第{}次排序过程'.format(i+1))
        for j in range(i, 0, -1):
            if nums[j] < nums[j-1]:
                nums[j], nums[j-1] = nums[j-1], nums[j]
            print(nums)  # [1, 2, 3, 4, 5, 6, 7, 8]


def insertion_sort_2(nums):
    for i in range(1, len(nums)):
        print('第{}次排序过程'.format(i+1))
        for j in range(i):
            print(nums)
            if nums[i] > nums[j]:
                ins = nums[i]
                nums.pop(i)
                nums.insert(j, ins)
                break


def insertion_sort_3(nums):
    for i in range(len(nums)):
        print('第{}次排序过程'.format(i+1))
        for j in range(i):
            print(nums)
            if nums[i] < nums[j]:
                ins = nums[i]
                nums.pop(i)
                nums.insert(j, ins)
                break


if __name__ == "__main__":
    nums = [5, 3, 6, 4, 1, 2, 8, 7]
    print('原始数组...')
    print(nums)
    print('-'*30)
    insertion_sort_1(nums)

```

# 4、希尔排序

希尔排序，也称为递减增量排序算法，是插入排序的一种更高效的改进版本。但希尔排序是非稳定排序算法。

希尔排序是基于插入排序的以下两点性质提出改进方法的：
- 插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效果。
- 插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位

**希尔排序的基本思想是**：先将整个待排序的记录序列分割成若干子序列分别进行直接插入排序，待整个序列中的记录“基本有序”时，再对全体记录进行一次直接插入排序。

## 4.1 算法步骤

1. 选择一个增量序列 t1，t2，……，tk，其中 ti > tj, tk = 1；
2. 按增量序列个数k，对序列进行k趟排序；
3. 每趟排序，根据对应的增量ti，将待排序列分割若干长度为m的子序列，分别对各子表进行直接插入排序。仅增量因子为1时，整个序列作为一个表来处理，表长度即为整个序列的长度。

## 4.2 希尔排序动图图解

![希尔排序](./images/排序/希尔排序.gif)

## 4.3 代码实现

```python
def shell_sort(arr):
    import math
    gap = 1
    while gap < len(arr) / 3:
        gap = gap * 3 + 1
    while gap > 0:
        for i in range(gap, len(arr)):
            temp = arr[i]
            j = i - gap
            while j >= 0 and arr[j] > temp:
                arr[j+gap] = arr[j]
                j -= gap
            arr[j+gap] = temp
        gap = math.floor(gap / 3)
    print(arr)


if __name__ == "__main__":
    nums = [9, 5, 3, 6, 4, 1, 2, 8, 7]
    print('原始数组...')
    print(nums)
    print('-'*30)
    shell_sort(nums)

```

# 5、归并排序

归并排序（Merge Sort）是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。

归并排序的实现由两种方法
- 自上而下的递归
- 自上而下的迭代

## 5.1 算法步骤

1. shang申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列；
2. 设定两个指针，最初位置分别为两个已经排序序列的起始位置
3. 比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置
4. 重复步骤3直到某一指针到达序列尾
5. 将另一序列的所有元素直接复制到合并序列尾

## 5.2 归并排序动图图解

![归并排序](./images/排序/归并排序.gif)

```python
def merge_sort(arr):
    import math
    if len(arr) < 2:
        return arr
    middle = math.floor(len(arr) / 2)
    left, right = arr[: middle], arr[middle:]
    return merge(merge_sort(left), merge_sort(right))


def merge(left, right):
    result = []
    while left and right:
        if left[0] <= right[0]:
            result.append(left.pop(0))
        else:
            result.append(right.pop(0))
    while left:
        result.append(left.pop(0))
    while right:
        result.append(right.pop(0))
    return result


if __name__ == "__main__":
    nums = [9, 5, 3, 6, 4, 1, 2, 8, 7]
    print('原始数组...')
    print(nums)
    print('-'*30)
    print(merge_sort(nums))

```

# 6、快速排序

快速排序使用分治法（Divide and conquer）策略来把一个串行（list）分为两个字串行（sub-lists）

快速排序又是一种分而治之思想在排序算法上的典型应用。本质上来看，快速排序应该算是在冒泡排序基础上的递归分治法。

## 6.1 算法步骤
1. 从数列中挑出一个元素，称为“基准”（pivot）
2. 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准大的摆在基准的后面（形同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；
3. 递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序；

递归的最底部情形，是数列的大小是或一，也就是永远已经被排序好了。虽然一直递归下去，但是这个算法总会退出，因为在每次的迭代（iteration）中，它至少会把一个元素摆到它最后的位置去。

## 6.2 动图演示

![快速排序](./images/排序/快速排序.gif)

## 6.3 代码实现

```python
def quick_sort(arr, left=None, right=None):
    left = 0 if not isinstance(left, (int, float)) else left
    right = len(arr)-1 if not isinstance(right, (int, float)) else right
    if left < right:
        partitionIndex = partition(arr, left, right)
        quick_sort(arr, left, partitionIndex-1)
        quick_sort(arr, partitionIndex+1, right)
    return arr


def partition(arr, left, right):
    pivot = left
    index = pivot + 1
    i = index
    while i <= right:
        if arr[i] < arr[pivot]:
            swap(arr, i, index)
            index += 1
        i += 1
    swap(arr, pivot, index-1)
    return index-1


def swap(arr, i, j):
    arr[i], arr[j] = arr[j], arr[i]


if __name__ == "__main__":
    nums = [9, 5, 3, 6, 4, 1, 2, 8, 7]
    print('原始数组...')
    print(nums)
    print('-'*30)
    print(quick_sort(nums))

```

# 7、堆排序

堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子节点的键值对或索引总是小于（或者大于）它的父节点。堆排序可以说是一种利用堆的概念来排下序的选择排序。分为两种方法：
1. 大顶堆：每个节点的值都大于或等于其子节点的值，在堆排序算法中用于升序排列；
2. 小顶堆：每个节点的值都小于或等于其子节点的值，在堆排序算法中用于降序排列；

## 7.1 算法步骤
1. 创建一个堆H\[0....n-1\]
2. 把堆首（最大值）和堆尾互换；
3. 把堆的尺寸随小1，并调用shirft_down(0),目前把新的数组顶端数据调整到相应位置；
4. 重复步骤2，直到堆的尺寸为1。

## 7.2 动图演示

![堆排序](./images/排序/堆排序.gif)

## 7.3 代码实现

```python
def buildMaxHeap(arr):
    import math
    for i in range(math.floor(len(arr) / 2), -1, -1):
        heapify(arr, i)


def heapify(arr, i):
    left = 2 * i + 1
    right = 2 * i + 2
    largest = i
    if left < arrLen and arr[left] > arr[largest]:
        largest = left
    if right < arrLen and arr[right] > arr[largest]:
        largest = right

    if largest != i:
        swap(arr, i, largest)
        heapify(arr, largest)


def swap(arr, i, j):
    arr[i], arr[j] = arr[j], arr[i]


def heapSort(arr):
    global arrLen
    arrLen = len(arr)
    buildMaxHeap(arr)
    for i in range(len(arr) - 1, 0, -1):
        swap(arr, 0, i)
        arrLen -= 1
        heapify(arr, 0)
    return arr


if __name__ == "__main__":
    nums = [9, 5, 3, 6, 4, 1, 2, 8, 7]
    print('原始数组...')
    print(nums)
    print('-'*30)
    print(heapSort(nums))
```

# 8、计数排序

计数排序的核心在于将输入的数据值转换为健存储在额外开辟的数组空间中。作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。

动图演示

![计数排序](./images/排序/计数排序.gif)

```python
def countingSort(arr, maxValue):
    bucktLen = maxValue + 1
    bucket = [0] * bucktLen
    sortedIndex = 0
    arrLen = len(arr)
    for i in range(arrLen):
        if not bucket[arr[i]]:
            bucket[arr[i]] = 0
        bucket[arr[i]] += 1
    for j in range(bucktLen):
        while bucket[j] > 0:
            arr[sortedIndex] = j
            sortedIndex += 1
            bucket[j] -= 1
    return arr


if __name__ == "__main__":
    nums = [9, 5, 3, 6, 4, 1, 2, 8, 7]
    print('原始数组...')
    print(nums)
    print('-'*30)
    print(countingSort(nums, max(nums)))

```

# 9、桶排序

桶排序是计数排序的升级版。利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。为了使桶排序更加高效，需要做到
1. 在额外空间充足的情况下，尽量增大桶的数量
2. 使用的映射函数能够将输入的N各数据均匀的分配到K个桶中

```python
def bucket_sort(s):
    min_num = min(s)
    max_num = max(s)
    # 桶的大小
    bucket_range = (max_num - min_num) / len(s)
    # 桶数组
    count_list = [[] for i in range(len(s) + 1)]
    # 向桶数组中填数
    for i in s:
        count_list[int((i-min_num) // bucket_range)].append(i)
    s.clear()
    # 回填
    for i in count_list:
        for j in sorted(i):
            s.append(j)


if __name__ == '__main__':
    a = [3.2, 6, 8, 4, 2, 6, 7, 3]
    bucket_sort(a)
    print(a)

```

# 10、基数排序

基数排序是一种非比较型整数排序算法，其原理是将整数按位数切成不同的数字，然后按每个位数分别比较。由于也可以表达字符串和特定格式的浮点数，所以基数排序不是只能适用于整数

## 10.1 基数排序 vs 计数排序 vs 桶排序
这三种排序算法都利用了桶的概念，但对桶的使用方法上有明显差异：

- 基数排序：根据键值的每位数字来分配桶；
- 计数排序：每个桶只存储单一键值；
- 桶排序：每个桶存储一定范围的数值。

## 10.2 动图演示

![基数排序](./images/排序/基数排序.gif)

## 代码实现

```python
def RadixSort(l):
    i = 0   # 初始为个位排序
    n = 1   # 最小的位数置为1
    max_num = max(l)    # 待排序列中最大值
    while max_num > 10 ** n:    # 最大值是几位数
        n += 1
    while i < n:
        bucket = {}     # 用字典构建
        for x in range(10):
            bucket .etdefault(x, []) # 将桶置空
        for x in l:     # 对每一位进行排序
            radix = int((x / (10**i)) % 10) # 每位的基数
            bucket[radix].append(x) # 将对应的数组元素加入到相应位置的桶中
        j = 0
        for k in range(10):
            if bucket[k]:   # 桶不为空
                for v in bucket[k]: # 将桶中的元素放回到数组中
                    l[j] = v
                    j += 1
        i += 1
    return l
```
